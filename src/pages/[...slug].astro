---
import { getCollection } from "astro:content";
import PostLayout from "../layouts/PostLayout.astro";
import { getPostsDirectFromSupabase } from "../lib/supabase-direct";
import { marked } from 'marked';

export async function getStaticPaths(): Promise<Array<{params: {slug: string}, props: any}>> {
  // Get MDX posts from pages/posts directory
  const postFiles: any[] = await Astro.glob('./posts/*.{md,mdx}');
  const mdxPosts: any[] = postFiles.map((post: any) => ({
    data: post.frontmatter,
    slug: post.frontmatter.slug || post.file?.split('/').pop()?.replace(/\.(md|mdx)$/, '') || '',
    url: post.url,
    file: post.file,
    Content: post.default // Store the component
  }));
  
  // Get ONLY PUBLISHED Supabase posts untuk production
  const supabasePostsData = await getPostsDirectFromSupabase(1000, 'published');

  // Build popular categories (top 10) once from MDX + Supabase
  const counts: Record<string, number> = {};
  try {
    // From MDX collection (postsMdx)
    const mdxColl = await getCollection('postsMdx').catch(() => [] as any[]);
    for (const p of mdxColl) {
      const cats = Array.isArray(p.data?.category) ? p.data.category : (p.data?.category ? [p.data.category] : []);
      const tags = Array.isArray(p.data?.tags) ? p.data.tags : (p.data?.tags ? [p.data.tags] : []);
      for (const t of [...cats, ...tags]) {
        const name = typeof t === 'object' && (t as any).value ? String((t as any).value) : String(t || '');
        if (!name) continue;
        counts[name] = (counts[name] || 0) + 1;
      }
    }
    // From Supabase
    for (const p of (supabasePostsData||[])) {
      const cats = Array.isArray((p as any).category) ? (p as any).category : ((p as any).category ? [(p as any).category] : []);
      const tags = Array.isArray((p as any).tags) ? (p as any).tags : ((p as any).tags ? [(p as any).tags] : []);
      for (const t of [...cats, ...tags]) {
        const name = typeof t === 'object' && (t as any).value ? String((t as any).value) : String(t || '');
        if (!name) continue;
        counts[name] = (counts[name] || 0) + 1;
      }
    }
  } catch {}

  const popularCategories = Object.entries(counts)
    .map(([name, count]) => ({ name, count }))
    .sort((a, b) => b.count - a.count)
    .slice(0, 10);

  const mdxPostPaths: Array<{params: {slug: string}, props: any}> = mdxPosts.map((post: any) => ({
    params: { slug: post.slug },
    props: { post, source: 'mdx' as const, popularCategories },
  }));

  // Add Supabase posts to root level
  const supabasePostPaths = (supabasePostsData||[])
    .filter((post: any) => post.slug && typeof post.slug === 'string')
    .map((post: any) => ({
      params: { slug: post.slug },
      props: { post, source: 'supabase' as const, popularCategories },
    }));
  
  return [...mdxPostPaths, ...supabasePostPaths];
}

type Props = {
  post: any;
  source: 'mdx' | 'page' | 'supabase';
  popularCategories?: Array<{ name: string; count: number }>;
};

const { post, source } = Astro.props as any;

// Helper function untuk memproses konten HTML (cleanup for prose styles)
const processContent = (content: string): string => {
  return content
    .replace(/<h1[^>]*>/g, '<h1>')
    .replace(/<h2[^>]*>/g, '<h2>')
    .replace(/<h3[^>]*>/g, '<h3>')
    .replace(/<h4[^>]*>/g, '<h4>')
    .replace(/<h5[^>]*>/g, '<h5>')
    .replace(/<h6[^>]*>/g, '<h6>')
    .replace(/<p[^>]*>/g, '<p>')
    .replace(/<ul[^>]*>/g, '<ul>')
    .replace(/<ol[^>]*>/g, '<ol>')
    .replace(/<li[^>]*>/g, '<li>')
    .replace(/<blockquote[^>]*>/g, '<blockquote>')
    .replace(/<pre[^>]*>/g, '<pre>')
    .replace(/<code[^>]*>/g, '<code>')
    .replace(/<table[^>]*>/g, '<table>')
    .replace(/<th[^>]*>/g, '<th>')
    .replace(/<td[^>]*>/g, '<td>')
    .replace(/<img([^>]*?)src="([^"]*)"([^>]*?)>/g, '<img$1src="$2"$3 loading="lazy">')
    .replace(/\s+/g, ' ')
    .trim();
};

// Prepare layout data based on source
let layoutData: any;
let processedContent: string = "";
let wordCount: number;
let Content: any;

if (source === 'supabase') {
  Content = undefined;
  const rawContent = post.body || post.content || "";
  const htmlContent = /<\w+[^>]*>/.test(rawContent) ? rawContent : await marked(rawContent);
  processedContent = processContent(htmlContent);
  wordCount = processedContent.split(' ').length;
  const imageUrl = post.cover_image || post.featured_image || post.imageUrl || post.coverImage || post.image || post.thumbnail || "";
  layoutData = {
    title: post.title,
    description: post.description || post.excerpt || "",
    imageUrl: imageUrl,
    coverImage: imageUrl,
    image: imageUrl,
    published: post.published ? new Date(post.published) : (post.created_at ? new Date(post.created_at) : new Date()),
    updated: post.updated ? new Date(post.updated) : (post.updated_at ? new Date(post.updated_at) : new Date()),
    tags: post.tags || [],
    category: post.category || post.categories || [],
    author: post.author || "Kotacom.id",
    source: 'supabase',
    popularCategories: ((Astro.props as any).popularCategories || [])
  };
} else if (source === 'mdx') {
  Content = post.Content;
  wordCount = 0;
  layoutData = {
    title: post.data.title,
    description: post.data.description || "",
    image: post.data.coverImage || "",
    published: post.data.published,
    updated: post.data.lastUpdated || post.data.published,
    tags: post.data.tags || [],
    author: "Kotacom.id",
    source: 'mdx',
    popularCategories: ((Astro.props as any).popularCategories || [])
  };
}

---

<PostLayout {...layoutData} wordCount={wordCount} popularCategories={layoutData.popularCategories}>
  {source === 'supabase' ? (
    <div set:html={processedContent} />
  ) : (
    <Content />
  )}
</PostLayout>

<style>
  /* Override breadcrumb untuk post Sanity/Directus */
  .breadcrumb-directus {
    display: none;
  }
</style>