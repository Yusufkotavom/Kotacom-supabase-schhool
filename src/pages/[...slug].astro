---
import { getCollection } from "astro:content";
import PostLayout from "../layouts/PostLayout.astro";
import { getPostsDirectFromSupabase } from "../lib/supabase-direct";
import { renderLexicalBlocks } from "../lib/lexical-renderer";
import { marked } from 'marked';
import { logger } from "../lib/logger";

export async function getStaticPaths(): Promise<Array<{params: {slug: string}, props: any}>> {
  // Get MDX posts from pages/posts directory
  const postFiles: any[] = await Astro.glob('./posts/*.{md,mdx}');
  const mdxPosts: any[] = postFiles.map((post: any) => ({
    data: post.frontmatter,
    slug: post.frontmatter.slug || post.file?.split('/').pop()?.replace(/\.(md|mdx)$/, '') || '',
    url: post.url,
    file: post.file,
    Content: post.default // Store the component
  }));
  
  // ✅ Get posts directly from Supabase (reduced limit for build performance)
  logger.info('Fetching posts from Supabase...');
  let supabasePostsData: any[] = [];

  try {
    // Fetch all published posts for complete static path generation
    supabasePostsData = await getPostsDirectFromSupabase(null, 'published');
    logger.success(`Successfully fetched ${supabasePostsData.length} posts from Supabase`);
  } catch (error) {
    logger.error('❌ Failed to fetch Supabase posts, continuing with MDX posts only:', error);
    // Continue with empty array - at least MDX posts will work
    supabasePostsData = [];
  }

  // Build popular categories (top 10) once from MDX + Supabase
  const counts: Record<string, number> = {};
  try {
    // From MDX collection (postsMdx)
    const mdxColl = await getCollection('postsMdx').catch(() => [] as any[]);
    for (const p of mdxColl) {
      const cats = Array.isArray(p.data?.category) ? p.data.category : (p.data?.category ? [p.data.category] : []);
      const tags = Array.isArray(p.data?.tags) ? p.data.tags : (p.data?.tags ? [p.data.tags] : []);
      for (const t of [...cats, ...tags]) {
        const name = typeof t === 'object' && (t as any).value ? String((t as any).value) : String(t || '');
        if (!name) continue;
        counts[name] = (counts[name] || 0) + 1;
      }
    }
    // From Supabase
    for (const p of (supabasePostsData||[])) {
      const cats = Array.isArray((p as any).category) ? (p as any).category : ((p as any).category ? [(p as any).category] : []);
      const tags = Array.isArray((p as any).tags) ? (p as any).tags : ((p as any).tags ? [(p as any).tags] : []);
      for (const t of [...cats, ...tags]) {
        const name = typeof t === 'object' && (t as any).value ? String((t as any).value) : String(t || '');
        if (!name) continue;
        counts[name] = (counts[name] || 0) + 1;
      }
    }
  } catch {}

  const popularCategories = Object.entries(counts)
    .map(([name, count]) => ({ name, count }))
    .sort((a, b) => b.count - a.count)
    .slice(0, 10);

  const mdxPostPaths: Array<{params: {slug: string}, props: any}> = mdxPosts.map((post: any) => ({
    params: { slug: post.slug },
    props: { post, source: 'mdx' as const, popularCategories },
  }));

  // Add Supabase posts to root level
  const supabasePostPaths = (supabasePostsData||[])
    .filter((post: any) => post.slug && typeof post.slug === 'string')
    .map((post: any) => ({
      params: { slug: post.slug },
      props: { post, source: 'supabase' as const, popularCategories },
    }));
  
  return [...mdxPostPaths, ...supabasePostPaths];
}

type Props = {
  post: any;
  source: 'mdx' | 'page' | 'supabase';
  popularCategories?: Array<{ name: string; count: number }>;
};

const { post, source } = Astro.props as any;

// Helper function untuk memproses konten HTML (cleanup for prose styles)
const processContent = (content: string): string => {
  if (!content || typeof content !== 'string') return '';

  return content
    // Bersihkan whitespace berlebihan yang mungkin tersisa
    .replace(/\r\n/g, '\n')
    .replace(/\n{3,}/g, '\n\n')
    // Cleanup HTML attributes untuk prose styling
    .replace(/<h1[^>]*>/g, '<h1>')
    .replace(/<h2[^>]*>/g, '<h2>')
    .replace(/<h3[^>]*>/g, '<h3>')
    .replace(/<h4[^>]*>/g, '<h4>')
    .replace(/<h5[^>]*>/g, '<h5>')
    .replace(/<h6[^>]*>/g, '<h6>')
    .replace(/<p[^>]*>/g, '<p>')
    .replace(/<ul[^>]*>/g, '<ul>')
    .replace(/<ol[^>]*>/g, '<ol>')
    .replace(/<li[^>]*>/g, '<li>')
    .replace(/<blockquote[^>]*>/g, '<blockquote>')
    .replace(/<pre[^>]*>/g, '<pre>')
    .replace(/<code[^>]*>/g, '<code>')
    .replace(/<table[^>]*>/g, '<table>')
    .replace(/<th[^>]*>/g, '<th>')
    .replace(/<td[^>]*>/g, '<td>')
    // Tambahkan lazy loading untuk images
    .replace(/<img([^>]*?)src="([^"]*)"([^>]*?)>/g, '<img$1src="$2"$3 loading="lazy">')
    // Bersihkan multiple spaces
    .replace(/ {2,}/g, ' ')
    .trim();
};

// Prepare layout data based on source
let layoutData: any;
let processedContent: string = "";
let wordCount: number = 0; // ✅ Initialize wordCount
let Content: any;

if (source === 'supabase') {
  Content = undefined;
  

  
  // ✅ Render content blocks dan body markdown secara berurutan
  let contentHtml = '';
  let bodyHtml = '';
  
  // 1. Render content blocks jika ada
  if (post.content && typeof post.content === 'object') {
    try {
      contentHtml = renderLexicalBlocks(post.content);
      logger.success('Content blocks rendered for:', post.slug);
    } catch (error) {
      logger.error('❌ Error rendering content blocks:', error);
      contentHtml = '';
    }
  }
  
  // 2. Render body markdown jika ada (sudah diproses di supabase-direct.ts)
  if (post.body && typeof post.body === 'string') {
    try {
      // ✅ Content sudah diproses di supabase-direct.ts, hanya perlu cleanup HTML
      bodyHtml = processContent(post.body);
    } catch (error) {
      logger.error('❌ Error processing body content:', error);
      bodyHtml = '';
    }
  }
  
  // 3. Combine content + body
  if (contentHtml && bodyHtml) {
    processedContent = contentHtml + bodyHtml;
  } else if (contentHtml) {
    processedContent = contentHtml;
  } else if (bodyHtml) {
    processedContent = bodyHtml;
  } else {
    processedContent = "";
  }
  
  wordCount = processedContent.split(' ').length;
  const imageUrl = post.cover_image || post.featured_image || post.imageUrl || post.coverImage || post.image || post.thumbnail || "";
  layoutData = {
    title: post.title,
    description: post.description || post.excerpt || "",
    imageUrl: imageUrl,
    coverImage: imageUrl,
    image: imageUrl,
    published: post.published ? new Date(post.published) : (post.created_at ? new Date(post.created_at) : new Date()),
    updated: post.updated ? new Date(post.updated) : (post.updated_at ? new Date(post.updated_at) : new Date()),
    tags: post.tags || [],
    category: post.category || post.categories || [],
    author: post.author || "Kotacom.id",
    source: 'supabase',
    popularCategories: ((Astro.props as any).popularCategories || [])
  };
} else if (source === 'mdx') {
  Content = post.Content;
  wordCount = 0;
  layoutData = {
    title: post.data.title,
    description: post.data.description || "",
    image: post.data.coverImage || "",
    published: post.data.published,
    updated: post.data.lastUpdated || post.data.published,
    tags: post.data.tags || [],
    author: "Kotacom.id",
    source: 'mdx',
    popularCategories: ((Astro.props as any).popularCategories || [])
  };
}

---

<PostLayout {...layoutData} wordCount={wordCount} popularCategories={layoutData.popularCategories}>
  {source === 'supabase' ? (
    <div set:html={processedContent} />
  ) : (
    <Content />
  )}
</PostLayout>

<style>
  /* Override breadcrumb untuk post Sanity/Directus */
  .breadcrumb-directus {
    display: none;
  }
</style>