---
import { getCollection } from "astro:content";
import { getPostsDirectFromSupabase, convertSupabasePost } from "../lib/supabase-direct";
import { toSlug } from "../utils/slug-helpers";

// Get the current category from the URL path
const currentCategoryPromise = (async () => {
  const pathSegments = Astro.url.pathname.split("/");
  const potentialCategory = pathSegments[2]; // Extract the category slug from the URL

  // Fetch posts from both sources
  const [mdxPosts, supabasePosts] = await Promise.all([
    getCollection('postsMdx').catch(() => [] as any[]),
    getPostsDirectFromSupabase(1000, 'published').catch(() => [] as any[])
  ]);

  // Normalize MDX posts
  const normalizedMdxPosts = mdxPosts.map((entry) => ({
    ...entry,
    source: 'mdx',
    data: {
      ...entry.data,
      properties: {
        bTitle: entry.data.title,
        bTags: entry.data.tags,
        bSlug: entry.data.slug,
        bCoverImage: entry.data.coverImage,
        bPublished: { start: entry.data.published },
        bLastUpdated: { start: entry.data.lastUpdated || entry.data.published },
        bDescription: entry.data.description,
      },
    },
  }));

  // Normalize Supabase posts
  const normalizedSupabasePosts = supabasePosts.map((post) => {
    const converted = convertSupabasePost(post);
    return {
      id: converted.id,
      source: 'supabase',
      data: {
        properties: {
          bTitle: converted.title,
          bTags: converted.tags,
          bSlug: converted.slug,
          bCoverImage: converted.coverImage,
          bPublished: { start: converted.published },
          bLastUpdated: { start: converted.updated },
          bDescription: converted.description,
        },
      },
    };
  });

  const allPosts = [...normalizedMdxPosts, ...normalizedSupabasePosts];
  
  const validCategories = allPosts.reduce((acc: Set<string>, post) => {
    const tags = Array.isArray(post.data.properties.bTags)
      ? post.data.properties.bTags.map((t: string) => t.toLowerCase().replace(/\s+/g, "-"))
      : [String(post.data.properties.bTags || "").toLowerCase().replace(/\s+/g, "-")];
    tags.forEach((tag: string) => {
      if (tag && tag !== "") acc.add(tag);
    });
    return acc;
  }, new Set<string>());

  return validCategories.has(potentialCategory) ? potentialCategory : null;
})();
const currentCategory = await currentCategoryPromise;

// Fetch posts from both sources
const [mdxPosts, supabasePosts] = await Promise.all([
  getCollection('postsMdx').catch(() => [] as any[]),
  getPostsDirectFromSupabase(1000, 'published').catch(() => [] as any[])
]);

// Normalize MDX posts (reuse the same logic)
const normalizedMdxPosts = mdxPosts.map((entry) => ({
  ...entry,
  source: 'mdx',
  data: {
    ...entry.data,
    properties: {
      bTitle: entry.data.title,
      bTags: entry.data.tags,
      bSlug: entry.data.slug,
      bCoverImage: entry.data.coverImage,
      bPublished: { start: entry.data.published },
      bLastUpdated: { start: entry.data.lastUpdated || entry.data.published },
      bDescription: entry.data.description,
    },
  },
}));

// Normalize Supabase posts
const normalizedSupabasePosts = supabasePosts.map((post) => {
  const converted = convertSupabasePost(post);
  return {
    id: converted.id,
    source: 'supabase',
    data: {
      properties: {
        bTitle: converted.title,
        bTags: converted.tags,
        bSlug: converted.slug,
        bCoverImage: converted.coverImage,
        bPublished: { start: converted.published },
        bLastUpdated: { start: converted.updated },
        bDescription: converted.description,
      },
    },
  };
});

// Combine all collections
const allPosts = [...normalizedMdxPosts, ...normalizedSupabasePosts];

// Count the number of posts for each tag
const tagCounts = allPosts.reduce((acc: Record<string, number>, post) => {
  const tags = Array.isArray(post.data.properties.bTags)
    ? post.data.properties.bTags
    : [post.data.properties.bTags];

  tags.forEach((tag: any) => {
    if (tag && tag.trim() !== "") {
      acc[tag] = (acc[tag] || 0) + 1;
    }
  });

  return acc;
}, {} as Record<string, number>);

// Extract unique tags and sort alphabetically
const uniqueTags = Object.keys(tagCounts).sort();
---
<form class="w-100%">
  <select
    id="categories"
    class="bg-white border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500"
    onchange="if (this.value) window.location.href = this.value"
  >
    <option 
      value="/"
      selected={!currentCategory}
    >
      Semua Kategori
    </option>
    {uniqueTags.map((tag) => {
      const tagSlug = toSlug(tag);
      return (
        <option
          value={`/category/${tagSlug}/`}
          selected={currentCategory === tagSlug}
        >
          {tag} ({tagCounts[tag]})
        </option>
      );
    })}
  </select>
</form>